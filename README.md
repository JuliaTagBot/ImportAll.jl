# ApproximateComputations.jl

[![Build Status](https://travis-ci.org/NTimmons/ApproximateComputations.jl.svg?branch=master)](https://travis-ci.org/NTimmons/ApproximateComputations.jl)[![codecov](https://codecov.io/gh/NTimmons/ApproximateComputations.jl/branch/master/graph/badge.svg)](https://codecov.io/gh/NTimmons/ApproximateComputations.jl)

ApproximateComputations.jl is a library for the automatic applicaiton approximate computation software techniques to existing code. In this context, software approximation is where we perform some transformation to existing code to reduce the accuracy for gain in performance.

This is usually applied through function replacement. The standard workflow is to determine the maximum or average acceptable error for a given code block and then reducing the accuracy of the function so that as little work as possible is spent on gaining a more acurate result that the acceptable level.


### Tutorial
An example of the usage of the small set of functions currently in this library is avialable below.
In this small example we show how to generate a replacement for the function 'sin' that has an average error when compared to the high-precision implementation of no more than 1x10^-8.


1) Generate new functions which approximate 'sin' in the range 0.001 to pi/2 
```
using ApproximateComputations
newFunctionsAndInformation = GenerateAllApproximationFunctions(sin, 0.001, 1.57)
```

2) Filter the generated functions to select the fastest executing function within our error constraint:
```
a = GetFastestAcceptable(newFunctionsAndInformation, meanErrorLimit=0.00000001)
println(GetFunctionName(a))  # -> returns sin_PolyLet9_Float64bit
```

3) Store the function for use:
```
approxsin = a.generatedFunction
```

4) Compare to accurate function:
```
approxResult = approxsin(1.0) # -> Approximation{Float64}(0.8414709848311571)
realResult = sin(1.0)   # -> {Float64} (0.8414709848078965)
```

#### Using the Approximation type:
Approximated functions return a type wrapped in Approximation.
This is to prevent unintentional mixing of approximate space data with high precision data.

5) To convert from an approximation to the original type we use Get(x)

```
x = Get(approxResult) # -> {Float64} (0.8414709848311571)
```

#### Extra function information:
To be able to produce and select an appropriate approximation the package also contains graphing functions to show the behaviours of the different functions generated by 'GenerateAllApproximationFunctions' as well as filtering functions select only the functions which match constraints on error, runtime or internal type precision.
